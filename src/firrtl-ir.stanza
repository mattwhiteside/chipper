defpackage firrtl/ir :
   import core
   import verse
   
public definterface Direction
public val INPUT = new Direction
public val OUTPUT = new Direction

public definterface Flip
public val DEFAULT = new Flip
public val REVERSE = new Flip

public definterface Width
public defstruct UnknownWidth <: Width
public defstruct IntWidth <: Width :
   width: Int

public definterface PrimOp
public val ADD-OP = new PrimOp
public val SUB-OP = new PrimOp
public val MUL-OP = new PrimOp
public val DIV-OP = new PrimOp
public val MOD-OP = new PrimOp
public val QUO-OP = new PrimOp
public val REM-OP = new PrimOp
public val ADD-WRAP-OP = new PrimOp
public val SUB-WRAP-OP = new PrimOp
public val LESS-OP = new PrimOp
public val LESS-EQ-OP = new PrimOp
public val GREATER-OP = new PrimOp
public val GREATER-EQ-OP = new PrimOp
public val EQUAL-OP = new PrimOp
public val NEQUAL-OP = new PrimOp
public val MUX-OP = new PrimOp
public val PAD-OP = new PrimOp
public val AS-UINT-OP = new PrimOp
public val AS-SINT-OP = new PrimOp
public val SHIFT-LEFT-OP = new PrimOp
public val DYN-SHIFT-LEFT-OP = new PrimOp
public val SHIFT-RIGHT-OP = new PrimOp
public val DYN-SHIFT-RIGHT-OP = new PrimOp
public val TO-UINT-OP = new PrimOp
public val TO-SINT-OP = new PrimOp
public val BIT-AND-OP = new PrimOp
public val BIT-OR-OP = new PrimOp
public val BIT-XOR-OP = new PrimOp
public val BIT-XOR-REDUCE-OP = new PrimOp
public val BIT-NOT-OP = new PrimOp
public val CONCAT-OP = new PrimOp
public val BIT-SELECT-OP = new PrimOp
public val BITS-SELECT-OP = new PrimOp

public val POW-OP = new PrimOp
public val SIN-OP = new PrimOp
public val COS-OP = new PrimOp
public val TAN-OP = new PrimOp
public val ASIN-OP = new PrimOp
public val ACOS-OP = new PrimOp
public val ATAN-OP = new PrimOp
public val SQRT-OP = new PrimOp
public val FLOOR-OP = new PrimOp
public val CEIL-OP = new PrimOp
public val ROUND-OP = new PrimOp
public val LOG-OP = new PrimOp

public definterface Expression
public defmulti type (e:Expression) -> Type

public defstruct NoExp <: Expression
defmethod type (e:NoExp) -> Type : UnknownType()

public defstruct Ref <: Expression :
   name: Symbol
   type: Type with: (as-method => true)
public defstruct Subfield <: Expression :
   exp: Expression
   name: Symbol
   type: Type with: (as-method => true)
public defstruct Index <: Expression :
   exp: Expression
   value: Int
   type: Type with: (as-method => true)
public defstruct FloValue <: Expression :
   value: Float
public defstruct UIntValue <: Expression :
   value: Int
   width: Width
public defstruct SIntValue <: Expression :
   value: Int
   width: Width
public defstruct DoPrim <: Expression :
   op: PrimOp
   args: List<Expression>
   consts: List<Int>
   type: Type with: (as-method => true)
public defstruct ReadPort <: Expression :
   mem: Expression
   index: Expression
   type: Type with: (as-method => true)
   enable: Expression
public defstruct WritePort <: Expression :
   mem: Expression
   index: Expression
   type: Type with: (as-method => true)
   enable: Expression
public defstruct Register <: Expression :
   type: Type with: (as-method => true)
   value: Expression
   enable: Expression
public defstruct Pad <: Expression :
   arg: Expression
   width: Width

public defmulti pad-to (x:Expression, w:Int, pad:Int) -> Expression

public defmethod pad-to (x:Expression, w:Int, pad:Int) -> Expression :
  ;; println-all(["PAD-TO E " x " W " w " PAD " pad])
  if pad == 0 or (pad > 0 and pad == w): x else: Pad(x, (if pad == -1: UnknownWidth() else: IntWidth(pad)))

public defmethod pad-to (x:SIntValue, w:Int, pad:Int) -> Expression :
  if pad == -1: Pad(x,UnknownWidth()) else: if pad == 0: x else: SIntValue(value(x), IntWidth(pad))

public defmethod pad-to (x:UIntValue, w:Int, pad:Int) -> Expression :
  ;; println-all(["PAD-TO L " x " W " w " PAD " pad])
  if pad == -1: Pad(x,UnknownWidth()) else: if pad == 0: x else: UIntValue(value(x), IntWidth(pad))

public definterface Stmt
public defstruct DefWire <: Stmt :
   name: Symbol
   type: Type
public defstruct DefRegister <: Stmt :
   name: Symbol
   type: Type
public defstruct DefInstance <: Stmt :
   name: Symbol
   module: Expression
public defstruct DefCMemory <: Stmt :
   name: Symbol
   type: VectorType
public defstruct DefSMemory <: Stmt :
   name: Symbol
   type: VectorType
public defstruct DefNode <: Stmt :
   name: Symbol
   value: Expression
public defstruct DefAccessor <: Stmt :
   name: Symbol
   source: Expression
   index: Expression
public defstruct Conditionally <: Stmt :
   pred: Expression
   conseq: Stmt
   alt: Stmt
public defstruct Begin <: Stmt :
   body: List<Stmt>
public defstruct Connect <: Stmt :
   loc: Expression
   exp: Expression
public defstruct OnReset <: Stmt :
   loc: Expression
   exp: Expression
public defstruct EmptyStmt <: Stmt


public definterface Type
public defstruct FloType <: Type 
public defstruct UIntType <: Type :
   width: Width
public defstruct SIntType <: Type :
   width: Width
public defstruct BundleType <: Type :
   fields: List<Field>
public defstruct VectorType <: Type :
   type: Type
   size: Int
public defstruct UnknownType <: Type

public defstruct Field :
   name: Symbol
   flip: Flip
   type: Type

public defstruct Port :
   name: Symbol
   direction: Direction
   type: Type

public defstruct Module :
   name: Symbol
   ports: List<Port>
   body: Stmt

public defstruct Circuit :
   modules: List<Module>
   main: Symbol
