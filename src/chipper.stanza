defpackage chipper :
   import core
   import verse
   import firrtl/ir with :
      prefix => f

public defn sizeof (in: Int) -> Int :
  max(1, ceil-log2(in + 1))

;Interface inherited by all handle classes
public definterface CHExp
public defmulti firrtl-exp (e:CHExp) -> fExpression
public defmulti firrtl-type (e:CHExp) -> fType
public defmulti handle<?T> (t:?T&CHExp, e:fExpression) -> T
public defmulti type<?T> (e:?T&CHExp) -> T

;Interface inherited by all module classes
public definterface CHModule <: CHExp
public defmulti firrtl-module (m:CHModule) -> Symbol

;WORKAROUND FOR STANZA BUG: Every multi needs to have at least one method.
defmethod firrtl-exp (e:CHExp) : error("Unimplemented.")
defmethod firrtl-type (t:CHExp) : error("Unimplemented.")
defmethod handle (t:CHExp, e:fExpression) : error("Unimplemented.")
defmethod type (e:CHExp) : error("Unimplemented.")
defmethod firrtl-module (m:CHModule) : error("Unimplemented.")

;=== Statement Vector ===
var STATEMENT-VECTOR:Vector<fStmt> = Vector<fStmt>()
defn build-statement (f: () -> ?) :
   let-var STATEMENT-VECTOR = Vector<fStmt>() :
      f()
      fBegin(to-list(STATEMENT-VECTOR))

;=== Module Vector ===
var MODULE-VECTOR:Vector<fModule> = Vector<fModule>()
defn Node (e:fExpression) :
   val name = gensym(`tmp)
   add(STATEMENT-VECTOR, fDefNode(name, e))
   fRef(name, fUnknownType())

;=== Component Creation ===
public defn RegisterExp<?T> (name:Symbol, type:?T&CHExp) :
   val name* = gensym(name)
   add(STATEMENT-VECTOR, fDefRegister(name*, firrtl-type(type)))
   handle(type, fRef(name*, fUnknownType()))

public defn MemExp<?T> (name:Symbol, type:?T&CHExp) -> T :
   val name* = gensym(name)
   add(STATEMENT-VECTOR, fDefMemory(name*, firrtl-type(type) as fVectorType))
   handle(type, fRef(name*, fUnknownType()))

public defn WireExp<?T> (name:Symbol, type:?T&CHExp) :
   val name* = gensym(name)
   add(STATEMENT-VECTOR, fDefWire(name*, firrtl-type(type)))
   handle(type, fRef(name*, fUnknownType()))

public defn InstanceExp<?T> (name:Symbol, module:?T&CHModule) :
   val name* = gensym(name)
   add(STATEMENT-VECTOR, fDefInstance(name*, fRef(firrtl-module(module), fUnknownType())))
   handle(module, fRef(name*, fUnknownType()))

public defn CircuitExp (module:CHModule) :
   let-var MODULE-VECTOR = Vector<fModule>() :
      val main = firrtl-module(module)
      fCircuit(to-list(MODULE-VECTOR), main)

public defn ConnectExp (x:CHExp, y:CHExp) :
   val x* = firrtl-exp(x)
   val y* = firrtl-exp(y)
   add(STATEMENT-VECTOR, fConnect(x*, y*))

public defn WhenExp (pred:CHExp, conseq: () -> ?, alt: () -> ?) :
   val p = firrtl-exp(pred)
   val c = build-statement(conseq)
   val a = build-statement(alt)
   add(STATEMENT-VECTOR, fConditionally(p, c, a))
   
public defn WhenExp (pred:CHExp, conseq: () -> ?) :
   val p = firrtl-exp(pred)
   val c = build-statement(conseq)
   add(STATEMENT-VECTOR, fConditionally(p, c, fEmptyStmt()))

public defn ModuleExp (name, ports:List<fPort>, f: () -> ?) -> Symbol :
   val name* = gensym(name)
   val body = build-statement(f)
   add(MODULE-VECTOR, fModule(name*, ports, body))
   name*

;Type Class for Vecs
public defclass Vec<T> <: CHExp & Streamable<T> & Lengthable
public defmulti get<?T> (v:Vec<?T>, i:Int) -> T
public defmulti get<?T> (v:Vec<?T>, i:CHExp) -> T
defn #Vec<T> (t:T&CHExp, len:Int, e:fExpression|False) :
   defn ensure-type () :
      if e not-typeof core/False :
         error("Cannot use expression handle as type.")
   defn ensure-exp () :
      if e typeof core/False :
         error("Cannot use type handle as expression.")
      e as fExpression   
   new Vec<T> :
      defmethod firrtl-exp (this) :
         ensure-exp()
      defmethod firrtl-type (this) :
         fVectorType(firrtl-type(t), len)
      defmethod handle (this, e2:fExpression) :
         ensure-type()
         #Vec<T>(t, len, e2)
      defmethod type (this) :
         ensure-exp()
         #Vec<T>(t, len, false)
      defmethod get (this, i:Int) :
         val e* = fIndex(ensure-exp(), i, fUnknownType())
         handle(t, e*)
      defmethod get (this, i:CHExp) :
         val name* = gensym(`a)
         add(STATEMENT-VECTOR, fDefAccessor(name*, ensure-exp(), firrtl-exp(i)))
         handle(t, fRef(name*, fUnknownType()))
      defmethod to-stream (this) :
         for i in 0 to len stream : this[i]
      defmethod length (this) :
         len         

public defn Vec<?T> (t:?T&CHExp, len:Int) :
   #Vec<T>(t, len, false)


;=== Type Class for UInts ===
public defclass UInt <: CHExp
defn #UInt (w:fWidth, e:fExpression|False) :
   defn ensure-type () :
      if e not-typeof core/False :
         error("Cannot use expression handle as type.")
   defn ensure-exp () :
      if e typeof core/False :
         error("Cannot use type handle as expression.")
      e as fExpression   
   new UInt :      
      defmethod firrtl-exp (this) :
         ensure-exp()
      defmethod firrtl-type (this) :
         fUIntType(w)
      defmethod handle (this, e2:fExpression) :
         ensure-type()
         #UInt(w, e2)
      defmethod type (this) :
         ensure-exp()
         #UInt(w, false)   

public defn UIntType (w:Int) : #UInt(fIntWidth(w), false)
public defn UIntType () : #UInt(fUnknownWidth(), false)
public defn UIntLit (v:Int) : #UInt(fUnknownWidth(), fUIntValue(v, fUnknownWidth()))
public defn UIntLit (v:Int, w:Int) : #UInt(fIntWidth(w), fUIntValue(v, fIntWidth(w)))

public defn binop (op:fPrimOp, x:UInt, y:UInt) -> UInt :
   val n = Node $ fDoPrim(op, list(ex, ey), List(), fUnknownType()) where :
      val ex = firrtl-exp(x)
      val ey = firrtl-exp(y)
   #UInt(fUnknownWidth(), n)
public defn plus (x:UInt, y:UInt) : binop(fADD-OP, x, y)
public defn minus (x:UInt, y:UInt) : binop(fSUB-OP, x, y)
public defn times (x:UInt, y:UInt) : binop(fMUL-OP, x, y)
public defn divide (x:UInt, y:UInt) : binop(fDIV-OP, x, y)
public defn modulo (x:UInt, y:UInt) : binop(fMOD-OP, x, y)
public defn bit-and (x:UInt, y:UInt) : binop(fBIT-AND-OP, x, y)
public defn bit-or (x:UInt, y:UInt) : binop(fBIT-OR-OP, x, y)
public defn bit-xor (x:UInt, y:UInt) : binop(fBIT-XOR-OP, x, y)
public defn bit-equal? (x:UInt, y:UInt) : binop(fEQUAL-OP, x, y)
public defn less-eq? (x:UInt, y:UInt) : binop(fLESS-EQ-OP, x, y)
public defn less? (x:UInt, y:UInt) : binop(fLESS-OP, x, y)
public defn greater-eq? (x:UInt, y:UInt) : binop(fGREATER-EQ-OP, x, y)
public defn greater? (x:UInt, y:UInt) : binop(fGREATER-OP, x, y)
public defn concat (x:UInt, y:UInt) : binop(fCONCAT-OP, x, y)

public defn get (x:UInt, i:Int) -> UInt :
   val n = Node $ fDoPrim(fBIT-SELECT-OP, list(ex), list(i), fUnknownType()) where :
      val ex = firrtl-exp(x)
   #UInt(fUnknownWidth(), n)   
      
public defn get (x:UInt, i:Int, j:Int) -> UInt :
   val n = Node $ fDoPrim(fBITS-SELECT-OP, list(ex), list(i, j), fUnknownType()) where :
      val ex = firrtl-exp(x)
   #UInt(fUnknownWidth(), n)


;=== Type Class for Bools ===
;public defclass Bool <: CHExp 
;defn #Bool (e:fExpression|False) :
;   defn ensure-type () :
;      if e not-typeof False :
;         error("Cannot use expression handle as type.")
;   defn ensure-exp () :
;      if e typeof False :
;         error("Cannot use type handle as expression.")
;      e as fExpression
;   new Bool :
;      defmethod firrtl-exp (this) :
;         ensure-exp()
;      defmethod firrtl-type (this) :
;         fUIntType(fIntWidth(1))
;      defmethod handle (this, e2:fExpression) :
;         ensure-type()
;         #Bool(e2)
;      defmethod type (this) :
;         ensure-exp()
;         #Bool(false)
;
;public defn Bool () :
;   #Bool(false)
;
;public defn Bool (v:True|False) :
;   val exp = fUIntValue(1 when v else 0, fIntWidth(1))
;   #Bool(exp)