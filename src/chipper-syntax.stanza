#if-defined(STANDALONE-CHIPPER) :
   #include<"core/stringeater.stanza">
   #include<"core/macro-utils.stanza">
   #include<"compiler/stz-params.stanza">
   #include<"compiler/stz-algorithms.stanza">
   #include<"compiler/stz-lexer.stanza">
   #include<"compiler/stz-parser.stanza">
   #include<"compiler/stz-core-macros.stanza">

defpackage chipper/syntax :
   import core
   import verse
   import core/macro-utils
   import stz/lexer

;=============== CHIPPER PARSE STRUCTURES ==================
definterface Type
defstruct UIntT <: Type
defstruct UIntWT <: Type : (width)
defstruct SIntT <: Type
defstruct SIntWT <: Type : (width)
defstruct VecT <: Type : (type:Type, length)
defstruct NamedT <: Type : (name, targs:List<Type>, args:List)
defstruct ParamT <: Type : (name)
defstruct ExpT <: Type : (erase?:True|False, exp)

defstruct Field : (flip:True|False, name, type:Type)
defstruct DefBundle : (name, targs:List, arglist:List, fields:List<Field>)
defstruct Port : (input?:True|False, name, type:Type)
defstruct DefModule : (name, targs:List, arglist:List, ports:List<Port>, body:List)
defstruct RegisterStmt : (name, type:Type)
defstruct RegisterExp : (type:Type)
defstruct NodeStmt : (name, x)
defstruct MemStmt : (name, type:Type)
defstruct WireStmt : (name, type:Type)
defstruct WireExp : (type:Type)
defstruct InstanceStmt : (name, module:Type)
defstruct InstanceExp : (module:Type)
defstruct CircuitStmt : (name, module:Type)
defstruct WhenStmt : (pred, conseq, alt)
defstruct ConnectStmt : (x, y)
defstruct OnResetStmt : (x, y)
;============================================================

;============ DEBUG: PRINTING ===============================
defn commas (xs) : join(xs, ", ")
defmethod print (o:OutputStream, t:Type) :
   print{o, _} $ match(t) :
      (t:UIntT) : "UInt"
      (t:UIntWT) : "UInt<~>" << [width(t)]
      (t:SIntT) : "SInt"
      (t:SIntWT) : "SInt<~>" << [width(t)]
      (t:VecT) : "~[~]" << [type(t), length(t)]
      (t:NamedT) : "~<~@>(~@)" << [name(t), commas(targs(t)), commas(args(t))]
      (t:ParamT) : name(t)
      (t:ExpT) : "typeof~(~)" << ["<?>" when erase?(t) else "", exp(t)]

defmethod print (o:OutputStream, f:Field) :
   print(o, "~~ : ~" << [
      "flip " when flip(f) else ""
      name(f)
      type(f)])

defmethod print (o:OutputStream, b:DefBundle) :
   print(o, "defbundle ~<~@> ~ :" << [name(b), commas(targs(b)), arglist(b)])
   for f in fields(b) do : print(o, "\n   ~" << [f])

defmethod print (o:OutputStream, p:Port) :
   print(o, "~ ~ : ~" << [
      "input" when input?(p) else "output"
      name(p)
      type(p)])

defmethod print (o:OutputStream, m:DefModule) :
   print(o, "defmodule ~<~@> ~ :" << [name(m), targs(m), arglist(m)])
   for p in ports(m) do : print(o, "\n   ~" << [p])
   print(o, "\n   ~@" << [join(body(m), " ")])

defmethod print (o:OutputStream, s:RegisterStmt) :
   print(o, "reg ~ : ~" << [name(s), type(s)])

defmethod print (o:OutputStream, s:NodeStmt) :
   print(o, "node ~ : ~" << [name(s), x(s)])

defmethod print (o:OutputStream, s:MemStmt) :
   print(o, "mem ~ : ~" << [name(s), type(s)])

defmethod print (o:OutputStream, s:WireStmt) :
   print(o, "wire ~ : ~" << [name(s), type(s)])

defmethod print (o:OutputStream, s:InstanceStmt) :
   print(o, "inst ~ of ~" << [name(s), module(s)])

defmethod print (o:OutputStream, s:RegisterExp) :
   print(o, "regof ~" << [type(s)])

defmethod print (o:OutputStream, s:WireExp) :
   print(o, "wireof ~" << [type(s)])

defmethod print (o:OutputStream, s:InstanceExp) :
   print(o, "instof ~" << [module(s)])

defmethod print (o:OutputStream, s:CircuitStmt) :
   print(o, "circuit ~ of ~" << [name(s), module(s)])

defmethod print (o:OutputStream, s:WhenStmt) :
   val io = IndentedStream(o, 3)
   print(o, "when ~ :" << [pred(s)])
   print(io, "\n~" << [conseq(s)])
   print(o, "\nelse :")
   print(io, "\n~" << [alt(s)])

defmethod print (o:OutputStream, s:ConnectStmt) :
   print(o, "~ := ~" << [x(s), y(s)])

defmethod print (o:OutputStream, s:OnResetStmt) :
   print(o, "onreset ~ := ~" << [x(s), y(s)])
;============================================================

;================= CHIPPER PARSER ===========================
defn* apply-suffix-ops (t, fs:List) :
   if empty?(fs) : t
   else : apply-suffix-ops(head(fs)(t), tail(fs))

defsyntax chipper :
   ;Holds the current type parameters in scope
   var TYPE-PARAMETERS:List<Symbol> = List()
   defn add-params (ts) :
      append(stream(unwrap-token, ts), TYPE-PARAMETERS)
   defn tparam? (x) :
      contains?(TYPE-PARAMETERS, unwrap-token(x))

   ;Chipper Types
   defrule :
      symbol = (?x) when unwrap-token(x) typeof Symbol : x
      ch/ts = ((@of ?ts:#ch/type ...)) : ts
      ch/ts = () : List()
      ch/es = ((@do ?es:#exp ...)) : es
      ch/es = () : List()

      ch/type = (?t:#ch/term ?ops:#ch/op ...) : apply-suffix-ops(t, ops)
      ch/op = ((@get ?n:#exp)) : (fn (t) : VecT(t, n))
      ch/term = (?x) when tparam?(x) : ParamT(x)
      ch/term = (typeof<?>(?e:#exp)) : ExpT(true, e)
      ch/term = (typeof(?e:#exp)) : ExpT(false, e)
      ch/term = (UInt<?e:#exp>) : UIntWT(e)
      ch/term = (UInt) : UIntT()
      ch/term = (SInt<?e:#exp>) : SIntWT(e)
      ch/term = (SInt) : SIntT()
      ch/term = (?x:#symbol ?ts:#ch/ts ?es:#ch/es) : NamedT(x, ts, es)

   ;Helper Rules
   defrule :
      ch/targs = ((@of ?ts:#id! ...)) : ts
      ch/targs = () : List()
      ch/arglist = ((?arglist ...)) : arglist
      ch/arglist = () : List()

   ;Bundle Definition
   defrule :
      ch/field = (flip ?name:#id! : ?t:#ch/type) : Field(true, name, t)
      ch/field = (?name:#id! : ?t:#ch/type) : Field(false, name, t)
      prefix-op = (defbundle ?name:#id! ?ts:#ch/targs ?arglist:#ch/arglist :
                      ?body ...) :
         let-var TYPE-PARAMETERS = add-params(ts) :              
            match-syntax(body) :
               (?fs:#ch/field ...) :
                  compile(DefBundle(name, ts, arglist, fs))

   ;Module Definition
   defrule :
      ch/port = (input ?name:#id! : ?t:#ch/type) : Port(true, name, t)
      ch/port = (output ?name:#id! : ?t:#ch/type) : Port(false, name, t)
      prefix-op = (defmodule ?name:#id! ?ts:#ch/targs ?arglist:#ch/arglist :
                      ?body ...) :
         let-var TYPE-PARAMETERS = add-params(ts) :
            match-syntax(body) :
               (?ports:#ch/port ... ?stmts:#exps!) :
                  compile(DefModule(name, ts, arglist, ports, stmts))

   ;Register statement
   defrule :
      prefix-op = (reg ?name:#id! : ?type:#ch/type := ?e:#exp!) :
         expande $ list(
            compile(RegisterStmt(name, type))
            compile(ConnectStmt(name, e)))
      prefix-op = (reg ?name:#id! : ?type:#ch/type) :
         compile(RegisterStmt(name, type))
      prefix-op = (regof ?type:#ch/type) :
         compile(RegisterExp(type))

   ;Node statement
   defrule :
      prefix-op = (node ?name:#id! = ?x:#exp!) :
         compile(NodeStmt(name, x))

   ;Mem statement
   defrule :
      prefix-op = (mem ?name:#id! : ?type:#ch/type) :
         compile(MemStmt(name, type))

   ;Wire statement
   defrule :
      prefix-op = (wire ?name:#id! : ?type:#ch/type := ?e:#exp!) :
         expande $ list(
            compile(WireStmt(name, type))
            compile(ConnectStmt(name, e)))
      prefix-op = (wire ?name:#id! : ?type:#ch/type) :
         compile(WireStmt(name, type))
      prefix-op = (wireof ?type:#ch/type) :
         compile(WireExp(type))

   ;Instance Statement
   defrule :
      prefix-op = (inst ?name:#id! of ?module:#ch/type) :
         compile(InstanceStmt(name, module))
      prefix-op = (instof ?module:#ch/type) :
         compile(InstanceExp(module))

   ;Circuit Statement
   defrule :
      prefix-op = (circuit ?name:#id! of ?module:#ch/type) :
         compile(CircuitStmt(name, module))

   ;When Statement
   defrule when :
      when-exp = (when ?pred:#exp! #:! ?conseq:#exp! else : ?alt:#exp!) :
         compile(WhenStmt(pred, conseq, alt))
      when-exp = (when ?pred:#exp! #:! ?conseq:#exp! else ?alt:#when-exp) :
         compile(WhenStmt(pred, conseq, alt))
      when-exp = (when ?pred:#exp! #:! ?conseq:#exp!) :
         compile(WhenStmt(pred, conseq, false))
      prefix-op = (?e:#when-exp) :
         e         

   ;Connect Statement
   defrule :
      suffix-op = (:= ?y:#exp!) :
         fn (x) :
            compile(ConnectStmt(x, y))

   ;Reset Statement
   defrule :
      suffix-op = (<- ?y:#exp!) :
         fn (x) :
            compile(OnResetStmt(x, y))

   ;Invert expression
   defrule :
      prefix-op = (~ ! ?e:#exp!) :
         expande $ qquote(chipper/invert(~ e))

   ;Bit Comparison Operator
   defrule :
      suffix-op = (=== ?y:#exp!) :
         fn (x) :
            expande $ qquote(bit-equal?(~ x, ~ y))
      suffix-op = (!== ?y:#exp!) :
         fn (x) :
            expande $ qquote(bit-not-equal?(~ x, ~ y))

   ;Bool Logical Operators
   defrule :
      suffix-op = (&& ?y:#exp!) :
         fn (x) :
            expande $ qquote(chipper/bool-and(~ x, ~ y))
      suffix-op = (|| ?y:#exp!) :
         fn (x) :
            expande $ qquote(chipper/bool-or(~ x, ~ y))

   ;Dot Syntax for Field Access
   defrule :
      suffix-op = (. ?y:#id!) :
         fn (x) :
            val yname = to-symbol("field#~" << [y])
            qquote($do ~ yname ~ x)

   ;Literal Syntax
   defrule :
      prefix-op = (UInt(?v:#exp$)) :
         expande $ qquote(chipper/UIntLit(~ v))
      prefix-op = (UInt<?w:#exp$>(?v:#exp$)) :
         expande $ qquote(chipper/UIntLit(~ v, ~ w))
            
;============================================================

;================= CONTINUING EXPANSION =====================      
defn expande (form) :
   with-syntax(core) :
      match-syntax(form) :
         (?e:#exp) : e
;============================================================

;================= TYPE COMPILATION =========================
defn compile-to-type-exp (t:Type) :
   match(t) :
      (t:UIntT) :
         qquote(chipper/UIntType())
      (t:UIntWT) :
         qquote(chipper/UIntType(~ (width(t))))
      (t:SIntT) :
         qquote(chipper/SIntType())
      (t:SIntWT) :
         qquote(chipper/SIntType(~ (width(t))))
      (t:VecT) :
         fill-template(`(chipper/Vec(t, len)), [
            `t => compile-to-type-exp(type(t))
            `len => length(t)])
      (t:NamedT) :
         fill-template(`(name(ts, args)), [
            `name => name(t)
            `ts => splice(map(compile-to-type-exp, targs(t)))
            `args => splice(args(t))])
      (t:ParamT) :
         name(t)
      (t:ExpT) :
         if erase?(t) :
            qquote(chipper/erase-width(chipper/type(~ (exp(t)))))
         else :
            qquote(chipper/type(~ (exp(t))))

defn compile-to-type (t:Type) :
   match(t) :
      (t:UIntT|UIntWT) :
         qquote(chipper/UInt)
      (t:SIntT|SIntWT) :
         qquote(chipper/SInt)
      (t:VecT) :
         fill-template(`(chipper/Vec<T>), [
            `T => compile-to-type(type(t))])
      (t:NamedT) :
         fill-template(`(name<Ts>), [
            `name => name(t)
            `Ts => splice(map(compile-to-type, targs(t)))])
      (t:ParamT) :
         name(t)
      (t:ExpT) :
         error("Cannot calculate type from ExpT")
;============================================================

;================= BUNDLE COMPILATION =======================
defn compile (b:DefBundle) :
   val template = `((
      defclass A<targs{T}> <: chipper/Data
      fields{
         defmulti field#name<targs{?T}> (a:A<targs{?T}>) -> type
      }
      defn #A<targs{T}> (fields{ft:type&chipper/Data}, e:firrtl/ir/Expression|core/False) :
         defn ensure-type () :
            if e not-typeof core/False :
               error("Cannot use expression handle as type.")
         defn ensure-exp () :
            if e typeof core/False :
               error("Cannot use type handle as expression.")
            e as firrtl/ir/Expression   

         new A<targs{T}> :
            defmethod chipper/firrtl-exp (this) :
               ensure-exp()
            defmethod chipper/firrtl-type (this) :
               firrtl/ir/BundleType $ to-list $ [fields{
                  firrtl/ir/Field(`name,
                     flip{firrtl/ir/REVERSE}{firrtl/ir/DEFAULT},
                     chipper/firrtl-type(ft))
               }]
            defmethod chipper/erase-width (this) :
              ensure-type()
              #A<targs{T}>(fields{chipper/erase-width(ft)}, false)
            fields{
               defmethod field#name (this) :
                  chipper/handle(ft, firrtl/ir/Subfield(ensure-exp(), `name, firrtl/ir/UnknownType()))
            }
            defmethod chipper/handle (this, e2:firrtl/ir/Expression) :
               ensure-type()
               #A<targs{T}>(fields{ft}, e2)
            defmethod chipper/type (this) :
               ensure-exp()
               #A<targs{T}>(fields{ft}, false)
      defn A<targs{?T}> (targs{T:?T&chipper/Data}, args) :
         #A<targs{T}>(fields{type-exp}, false)))
   val r = fill-template(template, [
      `A => name(b)
      `#A => gensym(name(b))
      `a => gensym(`a)
      `e => gensym(`e)
      `ensure-type => gensym(`ensure-type)
      `ensure-exp => gensym(`ensure-exp)
      `args => splice(arglist(b))
      `targs => collect $ [
         `T => targs(b)]
      `fields => nested $ for f in fields(b) stream : [
         `ft => gensym(`T)
         `name => name(f)
         `flip => choice(flip(f))
         `field#name => to-symbol("field#~" << [name(f)])
         `type => compile-to-type(type(f))
         `type-exp => compile-to-type-exp(type(f))]])
   println("=== Expanding Bundle ===")      
   println(r)
   expande(r)
;============================================================

;================ DEFMODULE COMPILATION =====================
defn compile (b:DefModule) :
   val template = `((
      defclass A<targs{T}> <: chipper/CHModule
      ports{
         defmulti field#name<targs{?T}> (a:A<targs{?T}>) -> type
      }
      defn #A<targs{T}> (ports{pt:type&chipper/Data}, eval-body: () -> ?, e:firrtl/ir/Expression|core/False) :
         defn ensure-type () :
            if e not-typeof core/False :
               error("Cannot use expression handle as type.")
         defn ensure-exp () :
            if e typeof core/False :
               error("Cannot use type handle as expression.")
            e as firrtl/ir/Expression   

         new A<targs{T}> :
            defmethod chipper/firrtl-module (this) :
               val fs = to-list $ [ports{
                  firrtl/ir/Port(`name,
                     flip{firrtl/ir/INPUT}{firrtl/ir/OUTPUT},
                     chipper/firrtl-type(pt))
               }]
               chipper/ModuleExp(`A, fs, eval-body)
            defmethod chipper/firrtl-exp (this) :
               ensure-exp()
            defmethod chipper/erase-width (this) :
              ensure-type()
              #A<targs{T}>(ports{chipper/erase-width(pt)}, eval-body, false)
            defmethod chipper/firrtl-type (this) :
               firrtl/ir/BundleType $ to-list $ [ports{
                  firrtl/ir/Field(`name,
                     flip{firrtl/ir/REVERSE}{firrtl/ir/DEFAULT},
                     chipper/firrtl-type(pt))
               }]
            ports{
               defmethod field#name (this) :
                  chipper/handle(pt, firrtl/ir/Subfield(ensure-exp(), `name, firrtl/ir/UnknownType()))
            }
            defmethod chipper/handle (this, e2:firrtl/ir/Expression) :
               ensure-type()
               #A<targs{T}>(ports{pt}, eval-body, e2)
            defmethod chipper/type (this) :
               ensure-exp()
               #A<targs{T}>(ports{pt}, eval-body, false)
      defn A<targs{?T}> (targs{T:?T&chipper/Data}, args) :
         ports{val pt = type-exp}
         defn eval-body () : 
            ports{val name = chipper/handle(pt, firrtl/ir/Ref(`name, firrtl/ir/UnknownType()))}
            body                     
         #A<targs{T}>(ports{pt}, eval-body, false)))
   val r = fill-template(template, [
      `A => name(b)
      `#A => gensym(name(b))
      `a => gensym(`a)
      `e => gensym(`e)
      `fs => gensym(`fs)      
      `ensure-type => gensym(`ensure-type)
      `ensure-exp => gensym(`ensure-exp)
      `eval-body => gensym(`eval-body)
      `args => splice(arglist(b))
      `body => body(b)      
      `targs => collect $ [
         `T => targs(b)]
      `ports => nested $ for p in ports(b) stream : [
         `pt => gensym(`T)
         `name => name(p)
         `flip => choice(input?(p))
         `field#name => to-symbol("field#~" <<  [name(p)])
         `type => compile-to-type(type(p))
         `type-exp => compile-to-type-exp(type(p))]])
   println("=== Expanding Module ===")
   println(r)
   expande(r)
;============================================================

;================= REGISTER COMPILATION =====================
defn compile (s:RegisterStmt) :
   val template = `(
      val name = chipper/RegisterExp(`name, type))
   expande $ fill-template(template, [
      `name => name(s)
      `type => compile-to-type-exp(type(s))])
      
defn compile (s:RegisterExp) :
   val template = `(
      chipper/RegisterExp(`reg, type))
   expande $ fill-template(template, [
      `type => compile-to-type-exp(type(s))])
;============================================================

;================= WIRE COMPILATION =========================
defn compile (s:WireStmt) :
   val template = `(
      val name = chipper/WireExp(`name, type))
   expande $ fill-template(template, [
      `name => name(s)
      `type => compile-to-type-exp(type(s))])

defn compile (s:WireExp) :
   val template = `(
      chipper/WireExp(`w, type))
   expande $ fill-template(template, [
      `type => compile-to-type-exp(type(s))])
;============================================================

;================= NODE COMPILATION =========================
defn compile (s:NodeStmt) :
   val template = `(
      val name = chipper/NodeExp(`name, x))
   expande $ fill-template(template, [
      `name => name(s)
      `x => x(s)])
;============================================================

;================= Mem COMPILATION =========================
defn compile (s:MemStmt) :
   val template = `(
      val name = chipper/MemExp(`name, type))
   expande $ fill-template(template, [
      `name => name(s)
      `type => compile-to-type-exp(type(s))])
;============================================================

;================== ONRESET COMPILATION =====================
defn compile (s:OnResetStmt) :
   val template = `(
      chipper/OnResetExp(x, y))
   expande $ fill-template(template, [
      `x => x(s)
      `y => y(s)])
;============================================================

;=================== INSTANCE COMPILATION ===================
defn compile (s:InstanceStmt) :
   val template = `(
      val name = chipper/InstanceExp(`name, module))
   expande $ fill-template(template, [
      `name => name(s)
      `module => compile-to-type-exp(module(s))])

defn compile (s:InstanceExp) :
   val template = `(
      chipper/InstanceExp(`inst, module))
   expande $ fill-template(template, [
      `module => compile-to-type-exp(module(s))])
;============================================================

;================== CIRCUIT COMPILATION =====================
defn compile (s:CircuitStmt) :
   val template = `(
      val name = chipper/CircuitExp(module))
   expande $ fill-template(template, [
      `name => name(s)
      `module => compile-to-type-exp(module(s))])
;============================================================

;================ CONNECT COMPILATION =======================
defn compile (s:ConnectStmt) :
   val template = `(chipper/ConnectExp(x, y))
   expande $ fill-template(template, [
      `x => x(s)
      `y => y(s)])
;============================================================

;================== WHEN COMPILATION ========================
defn compile (s:WhenStmt) :
   val template = `(chipper/WhenExp(pred,
                       fn () : conseq
                       alt?{fn () : alt}{}))
   expande $ fill-template(template, [
      `pred => pred(s)
      `conseq => conseq(s)
      `alt? => choice(alt(s) != false)
      `alt => alt(s)])
;============================================================


;================== STANDALONE TESTING ======================
#if-defined(STANDALONE-CHIPPER) :
   defn main () :
      val lexed = lex-file(commandline-arguments()[1])
      with-syntax(core, chipper) :
         match-syntax(lexed) :
            (?bs:#exp ...) :
               do(println, bs)
   main()
;============================================================
